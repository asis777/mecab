<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MeCab: MeCab::Tagger Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MeCab
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMeCab.html">MeCab</a></li><li class="navelem"><a class="el" href="classMeCab_1_1Tagger.html">Tagger</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classMeCab_1_1Tagger-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MeCab::Tagger Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> class.  
 <a href="classMeCab_1_1Tagger.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mecab_8h_source.html">mecab.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8abeb4a19c4ec5bd7784b95b38a88a4d" id="r_a8abeb4a19c4ec5bd7784b95b38a88a4d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a8abeb4a19c4ec5bd7784b95b38a88a4d">parse</a> (<a class="el" href="classMeCab_1_1Lattice.html">Lattice</a> *lattice) const =0</td></tr>
<tr class="memdesc:a8abeb4a19c4ec5bd7784b95b38a88a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse lattice object.  <br /></td></tr>
<tr class="separator:a8abeb4a19c4ec5bd7784b95b38a88a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6b457e836d03624da38d5fef4e3953" id="r_a5f6b457e836d03624da38d5fef4e3953"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a5f6b457e836d03624da38d5fef4e3953">parse</a> (const char *str)=0</td></tr>
<tr class="memdesc:a5f6b457e836d03624da38d5fef4e3953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse given sentence and return parsed result as string.  <br /></td></tr>
<tr class="separator:a5f6b457e836d03624da38d5fef4e3953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7191eaebfd7f6c45b0842dd2f45791" id="r_a0d7191eaebfd7f6c45b0842dd2f45791"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a0d7191eaebfd7f6c45b0842dd2f45791">parseToNode</a> (const char *str)=0</td></tr>
<tr class="memdesc:a0d7191eaebfd7f6c45b0842dd2f45791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse given sentence and return Node object.  <br /></td></tr>
<tr class="separator:a0d7191eaebfd7f6c45b0842dd2f45791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd469ad71fa37f4179c08e77869c4ab9" id="r_afd469ad71fa37f4179c08e77869c4ab9"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#afd469ad71fa37f4179c08e77869c4ab9">parseNBest</a> (size_t N, const char *str)=0</td></tr>
<tr class="memdesc:afd469ad71fa37f4179c08e77869c4ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse given sentence and obtain N-best results as a string format.  <br /></td></tr>
<tr class="separator:afd469ad71fa37f4179c08e77869c4ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52ae90664736f2e7caa5f9e7cc152a4" id="r_aa52ae90664736f2e7caa5f9e7cc152a4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4">parseNBestInit</a> (const char *str)=0</td></tr>
<tr class="memdesc:aa52ae90664736f2e7caa5f9e7cc152a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize N-best enumeration with a sentence.  <br /></td></tr>
<tr class="separator:aa52ae90664736f2e7caa5f9e7cc152a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba10aeb2f157b7258e716b35ecc57b73" id="r_aba10aeb2f157b7258e716b35ecc57b73"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aba10aeb2f157b7258e716b35ecc57b73">nextNode</a> ()=0</td></tr>
<tr class="memdesc:aba10aeb2f157b7258e716b35ecc57b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return next-best parsed result.  <br /></td></tr>
<tr class="separator:aba10aeb2f157b7258e716b35ecc57b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03fced14b7db396a5bf7ee3b1156108" id="r_ad03fced14b7db396a5bf7ee3b1156108"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ad03fced14b7db396a5bf7ee3b1156108">next</a> ()=0</td></tr>
<tr class="memdesc:ad03fced14b7db396a5bf7ee3b1156108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return next-best parsed result.  <br /></td></tr>
<tr class="separator:ad03fced14b7db396a5bf7ee3b1156108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899d5a871aacf2dd70c8d42f396a6340" id="r_a899d5a871aacf2dd70c8d42f396a6340"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a899d5a871aacf2dd70c8d42f396a6340">formatNode</a> (const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *node)=0</td></tr>
<tr class="memdesc:a899d5a871aacf2dd70c8d42f396a6340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return formatted node object.  <br /></td></tr>
<tr class="separator:a899d5a871aacf2dd70c8d42f396a6340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54668c11f6bd6b244bffbcdfd5f9bfd" id="r_ab54668c11f6bd6b244bffbcdfd5f9bfd"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ab54668c11f6bd6b244bffbcdfd5f9bfd">parse</a> (const char *str, size_t len, char *ostr, size_t olen)=0</td></tr>
<tr class="memdesc:ab54668c11f6bd6b244bffbcdfd5f9bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4" title="Handy static method.">parse()</a> method, but input length and output buffer are passed.  <br /></td></tr>
<tr class="separator:ab54668c11f6bd6b244bffbcdfd5f9bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae223906791fffa2774ec018317eca65b" id="r_ae223906791fffa2774ec018317eca65b"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ae223906791fffa2774ec018317eca65b">parse</a> (const char *str, size_t len)=0</td></tr>
<tr class="memdesc:ae223906791fffa2774ec018317eca65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4" title="Handy static method.">parse()</a> method, but input length can be passed.  <br /></td></tr>
<tr class="separator:ae223906791fffa2774ec018317eca65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cf23a7b67115a190f3fe52d9cce0f4" id="r_a42cf23a7b67115a190f3fe52d9cce0f4"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a42cf23a7b67115a190f3fe52d9cce0f4">parseToNode</a> (const char *str, size_t len)=0</td></tr>
<tr class="memdesc:a42cf23a7b67115a190f3fe52d9cce0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#a0d7191eaebfd7f6c45b0842dd2f45791" title="Parse given sentence and return Node object.">parseToNode()</a>, but input lenth can be passed.  <br /></td></tr>
<tr class="separator:a42cf23a7b67115a190f3fe52d9cce0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e690482db9d13aadb2ebcff87903ea0" id="r_a9e690482db9d13aadb2ebcff87903ea0"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a9e690482db9d13aadb2ebcff87903ea0">parseNBest</a> (size_t N, const char *str, size_t len)=0</td></tr>
<tr class="memdesc:a9e690482db9d13aadb2ebcff87903ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#afd469ad71fa37f4179c08e77869c4ab9" title="Parse given sentence and obtain N-best results as a string format.">parseNBest()</a>, but input length can be passed.  <br /></td></tr>
<tr class="separator:a9e690482db9d13aadb2ebcff87903ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c4e55a4dd12136ee062acdc1ce7419" id="r_ad5c4e55a4dd12136ee062acdc1ce7419"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ad5c4e55a4dd12136ee062acdc1ce7419">parseNBestInit</a> (const char *str, size_t len)=0</td></tr>
<tr class="memdesc:ad5c4e55a4dd12136ee062acdc1ce7419"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4" title="Initialize N-best enumeration with a sentence.">parseNBestInit()</a>, but input length can be passed.  <br /></td></tr>
<tr class="separator:ad5c4e55a4dd12136ee062acdc1ce7419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69530c0b3898bb46753ec85483a9052e" id="r_a69530c0b3898bb46753ec85483a9052e"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a69530c0b3898bb46753ec85483a9052e">next</a> (char *ostr, size_t olen)=0</td></tr>
<tr class="memdesc:a69530c0b3898bb46753ec85483a9052e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#ad03fced14b7db396a5bf7ee3b1156108" title="Return next-best parsed result.">next()</a>, but output buffer can be passed.  <br /></td></tr>
<tr class="separator:a69530c0b3898bb46753ec85483a9052e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac199ecb464d780adc181b0cdf9392b80" id="r_ac199ecb464d780adc181b0cdf9392b80"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ac199ecb464d780adc181b0cdf9392b80">parseNBest</a> (size_t N, const char *str, size_t len, char *ostr, size_t olen)=0</td></tr>
<tr class="memdesc:ac199ecb464d780adc181b0cdf9392b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#afd469ad71fa37f4179c08e77869c4ab9" title="Parse given sentence and obtain N-best results as a string format.">parseNBest()</a>, but input length and output buffer can be passed.  <br /></td></tr>
<tr class="separator:ac199ecb464d780adc181b0cdf9392b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3073637795fffef174569262ec347ef0" id="r_a3073637795fffef174569262ec347ef0"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a3073637795fffef174569262ec347ef0">formatNode</a> (const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *node, char *ostr, size_t olen)=0</td></tr>
<tr class="memdesc:a3073637795fffef174569262ec347ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#a899d5a871aacf2dd70c8d42f396a6340" title="Return formatted node object.">formatNode()</a>, but output buffer can be passed.  <br /></td></tr>
<tr class="separator:a3073637795fffef174569262ec347ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa320c5a940cf6208b4ee4734d14dd805" id="r_aa320c5a940cf6208b4ee4734d14dd805"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aa320c5a940cf6208b4ee4734d14dd805">set_request_type</a> (int <a class="el" href="classMeCab_1_1Tagger.html#ac0cbc3fb68436e9952ca526a83a87c59">request_type</a>)=0</td></tr>
<tr class="memdesc:aa320c5a940cf6208b4ee4734d14dd805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set request type.  <br /></td></tr>
<tr class="separator:aa320c5a940cf6208b4ee4734d14dd805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cbc3fb68436e9952ca526a83a87c59" id="r_ac0cbc3fb68436e9952ca526a83a87c59"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ac0cbc3fb68436e9952ca526a83a87c59">request_type</a> () const =0</td></tr>
<tr class="memdesc:ac0cbc3fb68436e9952ca526a83a87c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current request type.  <br /></td></tr>
<tr class="separator:ac0cbc3fb68436e9952ca526a83a87c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1493b6c89c5beec7e5260bf3b2db7f0f" id="r_a1493b6c89c5beec7e5260bf3b2db7f0f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a1493b6c89c5beec7e5260bf3b2db7f0f">partial</a> () const =0</td></tr>
<tr class="memdesc:a1493b6c89c5beec7e5260bf3b2db7f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if partial parsing mode is on.  <br /></td></tr>
<tr class="separator:a1493b6c89c5beec7e5260bf3b2db7f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39adde82d2e5d1c3474474ebb96bf946" id="r_a39adde82d2e5d1c3474474ebb96bf946"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a39adde82d2e5d1c3474474ebb96bf946">set_partial</a> (bool <a class="el" href="classMeCab_1_1Tagger.html#a1493b6c89c5beec7e5260bf3b2db7f0f">partial</a>)=0</td></tr>
<tr class="memdesc:a39adde82d2e5d1c3474474ebb96bf946"><td class="mdescLeft">&#160;</td><td class="mdescRight">set partial parsing mode.  <br /></td></tr>
<tr class="separator:a39adde82d2e5d1c3474474ebb96bf946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd70e1c67d6bbced9638bb94d816d40" id="r_a9bd70e1c67d6bbced9638bb94d816d40"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a9bd70e1c67d6bbced9638bb94d816d40">lattice_level</a> () const =0</td></tr>
<tr class="memdesc:a9bd70e1c67d6bbced9638bb94d816d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return lattice level.  <br /></td></tr>
<tr class="separator:a9bd70e1c67d6bbced9638bb94d816d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b77b24aca01af6b3193f40d23934f8" id="r_a17b77b24aca01af6b3193f40d23934f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a17b77b24aca01af6b3193f40d23934f8">set_lattice_level</a> (int level)=0</td></tr>
<tr class="memdesc:a17b77b24aca01af6b3193f40d23934f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set lattice level.  <br /></td></tr>
<tr class="separator:a17b77b24aca01af6b3193f40d23934f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af994ffd9dff8f053e6821454376b91e4" id="r_af994ffd9dff8f053e6821454376b91e4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#af994ffd9dff8f053e6821454376b91e4">all_morphs</a> () const =0</td></tr>
<tr class="memdesc:af994ffd9dff8f053e6821454376b91e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all morphs output mode is on.  <br /></td></tr>
<tr class="separator:af994ffd9dff8f053e6821454376b91e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3ce2e7465bf52dbfb84a3fa2c10680" id="r_aad3ce2e7465bf52dbfb84a3fa2c10680"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aad3ce2e7465bf52dbfb84a3fa2c10680">set_all_morphs</a> (bool <a class="el" href="classMeCab_1_1Tagger.html#af994ffd9dff8f053e6821454376b91e4">all_morphs</a>)=0</td></tr>
<tr class="memdesc:aad3ce2e7465bf52dbfb84a3fa2c10680"><td class="mdescLeft">&#160;</td><td class="mdescRight">set all-morphs output mode.  <br /></td></tr>
<tr class="separator:aad3ce2e7465bf52dbfb84a3fa2c10680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45cc74bbc6f6207ea709b26c0df0cc3" id="r_ad45cc74bbc6f6207ea709b26c0df0cc3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ad45cc74bbc6f6207ea709b26c0df0cc3">set_theta</a> (float <a class="el" href="classMeCab_1_1Tagger.html#aaa88870244d9acdaa96d216c33538708">theta</a>)=0</td></tr>
<tr class="memdesc:ad45cc74bbc6f6207ea709b26c0df0cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set temparature parameter theta.  <br /></td></tr>
<tr class="separator:ad45cc74bbc6f6207ea709b26c0df0cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa88870244d9acdaa96d216c33538708" id="r_aaa88870244d9acdaa96d216c33538708"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aaa88870244d9acdaa96d216c33538708">theta</a> () const =0</td></tr>
<tr class="memdesc:aaa88870244d9acdaa96d216c33538708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return temparature parameter theta.  <br /></td></tr>
<tr class="separator:aaa88870244d9acdaa96d216c33538708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8626312fa51dba07d553894b095128" id="r_aaf8626312fa51dba07d553894b095128"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceMeCab.html#a581b6e7f533add983ea9dabc4a44166b">DictionaryInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aaf8626312fa51dba07d553894b095128">dictionary_info</a> () const =0</td></tr>
<tr class="memdesc:aaf8626312fa51dba07d553894b095128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return DictionaryInfo linked list.  <br /></td></tr>
<tr class="separator:aaf8626312fa51dba07d553894b095128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6507efc03be35bff29eefd92e2cb6add" id="r_a6507efc03be35bff29eefd92e2cb6add"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a6507efc03be35bff29eefd92e2cb6add">what</a> () const =0</td></tr>
<tr class="memdesc:a6507efc03be35bff29eefd92e2cb6add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return error string.  <br /></td></tr>
<tr class="separator:a6507efc03be35bff29eefd92e2cb6add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73821650a97b4ca39a26f833014af516" id="r_a73821650a97b4ca39a26f833014af516"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a73821650a97b4ca39a26f833014af516">~Tagger</a> ()</td></tr>
<tr class="separator:a73821650a97b4ca39a26f833014af516"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a03c06efdb260ca0b2553f6fb1a3820f4" id="r_a03c06efdb260ca0b2553f6fb1a3820f4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4">parse</a> (const <a class="el" href="classMeCab_1_1Model.html">Model</a> &amp;model, <a class="el" href="classMeCab_1_1Lattice.html">Lattice</a> *lattice)</td></tr>
<tr class="memdesc:a03c06efdb260ca0b2553f6fb1a3820f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handy static method.  <br /></td></tr>
<tr class="separator:a03c06efdb260ca0b2553f6fb1a3820f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e85970c213252d4e369d0450b5ac11" id="r_af3e85970c213252d4e369d0450b5ac11"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMeCab_1_1Tagger.html">Tagger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#af3e85970c213252d4e369d0450b5ac11">create</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:af3e85970c213252d4e369d0450b5ac11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a new <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> with a specified main's argc/argv-style parameters.  <br /></td></tr>
<tr class="separator:af3e85970c213252d4e369d0450b5ac11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026222d5b60493db701a2b3d201b10a2" id="r_a026222d5b60493db701a2b3d201b10a2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMeCab_1_1Tagger.html">Tagger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a026222d5b60493db701a2b3d201b10a2">create</a> (const char *arg)</td></tr>
<tr class="memdesc:a026222d5b60493db701a2b3d201b10a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a new <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> with a string parameter representation, i.e., "-d /user/local/mecab/dic/ipadic -Ochasen".  <br /></td></tr>
<tr class="separator:a026222d5b60493db701a2b3d201b10a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbd551c6f890e79a0788c29ea5e0c7c" id="r_a8dbd551c6f890e79a0788c29ea5e0c7c"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a8dbd551c6f890e79a0788c29ea5e0c7c">version</a> ()</td></tr>
<tr class="memdesc:a8dbd551c6f890e79a0788c29ea5e0c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a version string.  <br /></td></tr>
<tr class="separator:a8dbd551c6f890e79a0788c29ea5e0c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a73821650a97b4ca39a26f833014af516" name="a73821650a97b4ca39a26f833014af516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73821650a97b4ca39a26f833014af516">&#9670;&#160;</a></span>~Tagger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MeCab::Tagger::~Tagger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af994ffd9dff8f053e6821454376b91e4" name="af994ffd9dff8f053e6821454376b91e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af994ffd9dff8f053e6821454376b91e4">&#9670;&#160;</a></span>all_morphs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MeCab::Tagger::all_morphs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if all morphs output mode is on. </p>
<p>This method is DEPRECATED. Use Lattice::has_request_type(MECAB_ALL_MORPHS). </p><dl class="section return"><dt>Returns</dt><dd>boolean </dd></dl>

</div>
</div>
<a id="a026222d5b60493db701a2b3d201b10a2" name="a026222d5b60493db701a2b3d201b10a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026222d5b60493db701a2b3d201b10a2">&#9670;&#160;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classMeCab_1_1Tagger.html">Tagger</a> * MeCab::Tagger::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create a new <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> with a string parameter representation, i.e., "-d /user/local/mecab/dic/ipadic -Ochasen". </p>
<p>Return NULL if new model cannot be initialized. Use <a class="el" href="namespaceMeCab.html#aedb04f02df3d615dfc7442ec1eb5c0d7" title="Return last error string.">MeCab::getLastError()</a> to obtain the cause of the errors. </p><dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classMeCab_1_1Model.html" title="Model class.">Model</a> object </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>single string representation of the argment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3e85970c213252d4e369d0450b5ac11" name="af3e85970c213252d4e369d0450b5ac11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e85970c213252d4e369d0450b5ac11">&#9670;&#160;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classMeCab_1_1Tagger.html">Tagger</a> * MeCab::Tagger::create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create a new <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> with a specified main's argc/argv-style parameters. </p>
<p>Return NULL if new model cannot be initialized. Use <a class="el" href="namespaceMeCab.html#aedb04f02df3d615dfc7442ec1eb5c0d7" title="Return last error string.">MeCab::getLastError()</a> to obtain the cause of the errors. </p><dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> object </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>number of parameters </td></tr>
    <tr><td class="paramname">argv</td><td>parameter list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf8626312fa51dba07d553894b095128" name="aaf8626312fa51dba07d553894b095128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8626312fa51dba07d553894b095128">&#9670;&#160;</a></span>dictionary_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceMeCab.html#a581b6e7f533add983ea9dabc4a44166b">DictionaryInfo</a> * MeCab::Tagger::dictionary_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return DictionaryInfo linked list. </p>
<dl class="section return"><dt>Returns</dt><dd>DictionaryInfo linked list </dd></dl>

</div>
</div>
<a id="a899d5a871aacf2dd70c8d42f396a6340" name="a899d5a871aacf2dd70c8d42f396a6340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899d5a871aacf2dd70c8d42f396a6340">&#9670;&#160;</a></span>formatNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::formatNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return formatted node object. </p>
<p>The format is specified with &ndash;unk-format, &ndash;bos-format, &ndash;eos-format, and &ndash;eon-format respectively. You should not delete the returned string. The returned buffer is overwritten when parse method is called again. This method is NOT thread safe. This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed result </dd></dl>

</div>
</div>
<a id="a3073637795fffef174569262ec347ef0" name="a3073637795fffef174569262ec347ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3073637795fffef174569262ec347ef0">&#9670;&#160;</a></span>formatNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::formatNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>olen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#a899d5a871aacf2dd70c8d42f396a6340" title="Return formatted node object.">formatNode()</a>, but output buffer can be passed. </p>
<p>Return NULL if more than |olen| buffer is required to store output string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node object </td></tr>
    <tr><td class="paramname">ostr</td><td>output buffer </td></tr>
    <tr><td class="paramname">olen</td><td>output buffer length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed result </dd></dl>

</div>
</div>
<a id="a9bd70e1c67d6bbced9638bb94d816d40" name="a9bd70e1c67d6bbced9638bb94d816d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd70e1c67d6bbced9638bb94d816d40">&#9670;&#160;</a></span>lattice_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MeCab::Tagger::lattice_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return lattice level. </p>
<p>This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a>::*_request_type() </p><dl class="section return"><dt>Returns</dt><dd>int lattice level </dd></dl>

</div>
</div>
<a id="ad03fced14b7db396a5bf7ee3b1156108" name="ad03fced14b7db396a5bf7ee3b1156108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03fced14b7db396a5bf7ee3b1156108">&#9670;&#160;</a></span>next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return next-best parsed result. </p>
<p>You must call <a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4" title="Initialize N-best enumeration with a sentence.">parseNBestInit()</a> in advance. Return NULL if no more reuslt is available. This method is NOT thread safe. This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p><dl class="section return"><dt>Returns</dt><dd>parsed result </dd></dl>

</div>
</div>
<a id="a69530c0b3898bb46753ec85483a9052e" name="a69530c0b3898bb46753ec85483a9052e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69530c0b3898bb46753ec85483a9052e">&#9670;&#160;</a></span>next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::next </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>olen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#ad03fced14b7db396a5bf7ee3b1156108" title="Return next-best parsed result.">next()</a>, but output buffer can be passed. </p>
<p>Return NULL if more than |olen| buffer is required to store output string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>output buffer </td></tr>
    <tr><td class="paramname">olen</td><td>output buffer length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed result </dd></dl>

</div>
</div>
<a id="aba10aeb2f157b7258e716b35ecc57b73" name="aba10aeb2f157b7258e716b35ecc57b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba10aeb2f157b7258e716b35ecc57b73">&#9670;&#160;</a></span>nextNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> * MeCab::Tagger::nextNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return next-best parsed result. </p>
<p>You must call <a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4" title="Initialize N-best enumeration with a sentence.">parseNBestInit()</a> in advance. Return NULL if no more reuslt is available. This method is NOT thread safe. This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p><dl class="section return"><dt>Returns</dt><dd>node object </dd></dl>

</div>
</div>
<a id="a5f6b457e836d03624da38d5fef4e3953" name="a5f6b457e836d03624da38d5fef4e3953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6b457e836d03624da38d5fef4e3953">&#9670;&#160;</a></span>parse() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse given sentence and return parsed result as string. </p>
<p>You should not delete the returned string. The returned buffer is overwritten when parse method is called again. This method is NOT thread safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed result </dd></dl>

</div>
</div>
<a id="ae223906791fffa2774ec018317eca65b" name="ae223906791fffa2774ec018317eca65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae223906791fffa2774ec018317eca65b">&#9670;&#160;</a></span>parse() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4" title="Handy static method.">parse()</a> method, but input length can be passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
    <tr><td class="paramname">len</td><td>sentence length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed result </dd></dl>

</div>
</div>
<a id="ab54668c11f6bd6b244bffbcdfd5f9bfd" name="ab54668c11f6bd6b244bffbcdfd5f9bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54668c11f6bd6b244bffbcdfd5f9bfd">&#9670;&#160;</a></span>parse() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>olen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4" title="Handy static method.">parse()</a> method, but input length and output buffer are passed. </p>
<p>Return parsed result as string. The result pointer is the same as |ostr|. Return NULL, if parsed result string cannot be stored within |olen| bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
    <tr><td class="paramname">len</td><td>sentence length </td></tr>
    <tr><td class="paramname">ostr</td><td>output buffer </td></tr>
    <tr><td class="paramname">olen</td><td>output buffer length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed result </dd></dl>

</div>
</div>
<a id="a03c06efdb260ca0b2553f6fb1a3820f4" name="a03c06efdb260ca0b2553f6fb1a3820f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c06efdb260ca0b2553f6fb1a3820f4">&#9670;&#160;</a></span>parse() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool MeCab::Tagger::parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeCab_1_1Model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMeCab_1_1Lattice.html">Lattice</a> *&#160;</td>
          <td class="paramname"><em>lattice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handy static method. </p>
<p>Return true if lattice is parsed successfully. This function is equivalent to { <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> *tagger = model.createModel(); const bool result = tagger-&gt;parse(lattice); delete tagger; return result; } </p><dl class="section return"><dt>Returns</dt><dd>boolean </dd></dl>

</div>
</div>
<a id="a8abeb4a19c4ec5bd7784b95b38a88a4d" name="a8abeb4a19c4ec5bd7784b95b38a88a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abeb4a19c4ec5bd7784b95b38a88a4d">&#9670;&#160;</a></span>parse() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MeCab::Tagger::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMeCab_1_1Lattice.html">Lattice</a> *&#160;</td>
          <td class="paramname"><em>lattice</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse lattice object. </p>
<p>Return true if lattice is parsed successfully. A sentence must be set to the lattice with <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a>:set_sentence object before calling this method. Parsed node object can be obtained with <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a>:bos_node. This method is thread safe. </p><dl class="section return"><dt>Returns</dt><dd>lattice lattice object </dd>
<dd>
boolean </dd></dl>

</div>
</div>
<a id="afd469ad71fa37f4179c08e77869c4ab9" name="afd469ad71fa37f4179c08e77869c4ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd469ad71fa37f4179c08e77869c4ab9">&#9670;&#160;</a></span>parseNBest() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::parseNBest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse given sentence and obtain N-best results as a string format. </p>
<p>Currently, N must be 1 &lt;= N &lt;= 512 due to the limitation of the buffer size. You should not delete the returned string. The returned buffer is overwritten when parse method is called again. This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>how many results you want to obtain </td></tr>
    <tr><td class="paramname">str</td><td>sentence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed result </dd></dl>

</div>
</div>
<a id="a9e690482db9d13aadb2ebcff87903ea0" name="a9e690482db9d13aadb2ebcff87903ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e690482db9d13aadb2ebcff87903ea0">&#9670;&#160;</a></span>parseNBest() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::parseNBest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#afd469ad71fa37f4179c08e77869c4ab9" title="Parse given sentence and obtain N-best results as a string format.">parseNBest()</a>, but input length can be passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>how many results you want to obtain </td></tr>
    <tr><td class="paramname">str</td><td>sentence </td></tr>
    <tr><td class="paramname">len</td><td>sentence length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed result </dd></dl>

</div>
</div>
<a id="ac199ecb464d780adc181b0cdf9392b80" name="ac199ecb464d780adc181b0cdf9392b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac199ecb464d780adc181b0cdf9392b80">&#9670;&#160;</a></span>parseNBest() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::parseNBest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>olen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#afd469ad71fa37f4179c08e77869c4ab9" title="Parse given sentence and obtain N-best results as a string format.">parseNBest()</a>, but input length and output buffer can be passed. </p>
<p>Return NULL if more than |olen| buffer is required to store output string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>how many results you want to obtain </td></tr>
    <tr><td class="paramname">str</td><td>input sentence </td></tr>
    <tr><td class="paramname">len</td><td>input sentence length </td></tr>
    <tr><td class="paramname">ostr</td><td>output buffer </td></tr>
    <tr><td class="paramname">olen</td><td>output buffer length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed result </dd></dl>

</div>
</div>
<a id="aa52ae90664736f2e7caa5f9e7cc152a4" name="aa52ae90664736f2e7caa5f9e7cc152a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52ae90664736f2e7caa5f9e7cc152a4">&#9670;&#160;</a></span>parseNBestInit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MeCab::Tagger::parseNBestInit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize N-best enumeration with a sentence. </p>
<p>Return true if initialization finishes successfully. N-best result is obtained by calling <a class="el" href="classMeCab_1_1Tagger.html#ad03fced14b7db396a5bf7ee3b1156108" title="Return next-best parsed result.">next()</a> or <a class="el" href="classMeCab_1_1Tagger.html#aba10aeb2f157b7258e716b35ecc57b73" title="Return next-best parsed result.">nextNode()</a> in sequence. This method is NOT thread safe. This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean </dd></dl>

</div>
</div>
<a id="ad5c4e55a4dd12136ee062acdc1ce7419" name="ad5c4e55a4dd12136ee062acdc1ce7419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c4e55a4dd12136ee062acdc1ce7419">&#9670;&#160;</a></span>parseNBestInit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MeCab::Tagger::parseNBestInit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4" title="Initialize N-best enumeration with a sentence.">parseNBestInit()</a>, but input length can be passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
    <tr><td class="paramname">len</td><td>sentence length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean </dd>
<dd>
parsed result </dd></dl>

</div>
</div>
<a id="a0d7191eaebfd7f6c45b0842dd2f45791" name="a0d7191eaebfd7f6c45b0842dd2f45791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7191eaebfd7f6c45b0842dd2f45791">&#9670;&#160;</a></span>parseToNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> * MeCab::Tagger::parseToNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse given sentence and return Node object. </p>
<p>You should not delete the returned node object. The returned buffer is overwritten when parse method is called again. You can traverse all nodes via <a class="el" href="structmecab__node__t.html#ad2f4b54dd0ee97c528fec86c90d00d2f" title="pointer to the next node.">Node::next</a> member. This method is NOT thread safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bos node object </dd></dl>

</div>
</div>
<a id="a42cf23a7b67115a190f3fe52d9cce0f4" name="a42cf23a7b67115a190f3fe52d9cce0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cf23a7b67115a190f3fe52d9cce0f4">&#9670;&#160;</a></span>parseToNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> * MeCab::Tagger::parseToNode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#a0d7191eaebfd7f6c45b0842dd2f45791" title="Parse given sentence and return Node object.">parseToNode()</a>, but input lenth can be passed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
    <tr><td class="paramname">len</td><td>sentence length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>node object </dd></dl>

</div>
</div>
<a id="a1493b6c89c5beec7e5260bf3b2db7f0f" name="a1493b6c89c5beec7e5260bf3b2db7f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1493b6c89c5beec7e5260bf3b2db7f0f">&#9670;&#160;</a></span>partial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MeCab::Tagger::partial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if partial parsing mode is on. </p>
<p>This method is DEPRECATED. Use Lattice::has_request_type(MECAB_PARTIAL). </p><dl class="section return"><dt>Returns</dt><dd>boolean </dd></dl>

</div>
</div>
<a id="ac0cbc3fb68436e9952ca526a83a87c59" name="ac0cbc3fb68436e9952ca526a83a87c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cbc3fb68436e9952ca526a83a87c59">&#9670;&#160;</a></span>request_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int MeCab::Tagger::request_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current request type. </p>
<p>This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p><dl class="section return"><dt>Returns</dt><dd>request type </dd></dl>

</div>
</div>
<a id="aad3ce2e7465bf52dbfb84a3fa2c10680" name="aad3ce2e7465bf52dbfb84a3fa2c10680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3ce2e7465bf52dbfb84a3fa2c10680">&#9670;&#160;</a></span>set_all_morphs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MeCab::Tagger::set_all_morphs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all_morphs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set all-morphs output mode. </p>
<p>This method is DEPRECATED. Use Lattice::add_request_type(MECAB_ALL_MORPHS) or Lattice::remove_request_type(MECAB_ALL_MORPHS) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all_morphs</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17b77b24aca01af6b3193f40d23934f8" name="a17b77b24aca01af6b3193f40d23934f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b77b24aca01af6b3193f40d23934f8">&#9670;&#160;</a></span>set_lattice_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MeCab::Tagger::set_lattice_level </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set lattice level. </p>
<p>This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a>::*_request_type() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>lattice level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39adde82d2e5d1c3474474ebb96bf946" name="a39adde82d2e5d1c3474474ebb96bf946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39adde82d2e5d1c3474474ebb96bf946">&#9670;&#160;</a></span>set_partial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MeCab::Tagger::set_partial </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>partial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set partial parsing mode. </p>
<p>This method is DEPRECATED. Use Lattice::add_request_type(MECAB_PARTIAL) or Lattice::remove_request_type(MECAB_PARTIAL) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partial</td><td>partial mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa320c5a940cf6208b4ee4734d14dd805" name="aa320c5a940cf6208b4ee4734d14dd805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa320c5a940cf6208b4ee4734d14dd805">&#9670;&#160;</a></span>set_request_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MeCab::Tagger::set_request_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>request_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set request type. </p>
<p>This method is DEPRECATED. Use Lattice::set_request_type(MECAB_PARTIAL). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request_type</td><td>new request type assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad45cc74bbc6f6207ea709b26c0df0cc3" name="ad45cc74bbc6f6207ea709b26c0df0cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45cc74bbc6f6207ea709b26c0df0cc3">&#9670;&#160;</a></span>set_theta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MeCab::Tagger::set_theta </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set temparature parameter theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>temparature parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa88870244d9acdaa96d216c33538708" name="aaa88870244d9acdaa96d216c33538708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa88870244d9acdaa96d216c33538708">&#9670;&#160;</a></span>theta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float MeCab::Tagger::theta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return temparature parameter theta. </p>
<dl class="section return"><dt>Returns</dt><dd>temparature parameter. </dd></dl>

</div>
</div>
<a id="a8dbd551c6f890e79a0788c29ea5e0c7c" name="a8dbd551c6f890e79a0788c29ea5e0c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbd551c6f890e79a0788c29ea5e0c7c">&#9670;&#160;</a></span>version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * MeCab::Tagger::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a version string. </p>
<dl class="section return"><dt>Returns</dt><dd>version string </dd></dl>

</div>
</div>
<a id="a6507efc03be35bff29eefd92e2cb6add" name="a6507efc03be35bff29eefd92e2cb6add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6507efc03be35bff29eefd92e2cb6add">&#9670;&#160;</a></span>what()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MeCab::Tagger::what </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return error string. </p>
<dl class="section return"><dt>Returns</dt><dd>error string </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/mecab/mecab/mecab/src/<a class="el" href="mecab_8h_source.html">mecab.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
